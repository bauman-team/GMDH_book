#!/usr/bin/env python
# coding: utf-8

# # Первые шаги

# ## О модуле
# 
# Модуль [gmdh](https://test.pypi.org/project/gmdh/) реализует 4 популярные разновидности алгоритмов из семейства метода группового учёта алгоритмов ([COMBI](../combi.ipynb), [MULTI](../multi.ipynb), [MIA](../mia.ipynb), [RIA](../ria.ipynb)), предназначенные для решения задач аппроксимации данных и предсказания временных рядов. Также в состав библиотеки входит вспомогательный функционал для базовой преобработки данных и сохранения уже обученных моделей.
# 
# Ядро модуля реализовано на языке С++, благодаря чему обеспечивается высокая производительность вычислений.
# 
# ```{note}
# Поддерживаемые версии Python: 3.6 и выше.
# ```
# 
# Репозиторий проекта: https://github.com/bauman-team/GMDH

# ## Установка
# 
# Для установки модуля `gmdh` достаточно выполнить команду:
# ```
# pip install gmdh
# ```
# 
# После этого модуль может быть импортирован в скрипте командой:
# ```python
# import gmdh
# ```

# ## Базовый пример

# Рассмотрим простейший пример использования базового комбинаторного алгоритма *COMBI* из модуля `gmdh`. 
# 
# Для начала импортируем из модуля модель `Combi` и функцию `split_data` для разбиения исходных данных на тренировчную и тестовую выборки:

# In[1]:


from gmdh import Combi, split_data


# Создадим простой датасет, в котором целевые значения матрицы `y` будут являться просто суммой соответствующей пары значений `x1` и `x2` матрицы `X`:

# In[2]:


X = [[1, 2], [3, 2], [7, 0], [5, 5], [1, 4], [2, 6]]
y = [3, 5, 7, 10, 5, 8]


# Разделим наши данные на тренировочную и тестовую выборки:

# In[3]:


x_train, x_test, y_train, y_test = split_data(X, y)

# выведем полученные массивы
print('x_train:\n', x_train)
print('x_test:\n', x_test)
print('\ny_train:\n', y_train)
print('y_test:\n', y_test)


# Создадим модель `Combi`, обучим её на наших тренировочных данных методом `fit` и затем предскажем результат для тестовой выборки методом `predict`:

# In[4]:


model = Combi()
model.fit(x_train, y_train)
y_predicted = model.predict(x_test)

# сравним прогноз с реальным значением
print('y_predicted: ', y_predicted)
print('y_test: ', y_test)


# Предсказанный результат совпал с реальным значением! Выведем теперь полином, отображающий найденную моделью закономерность:

# In[5]:


model.get_best_polynomial()


# ## Что дальше?

# Возможности модуля намного шире, чем было продемонстрировано в примере выше:
# 
# - имеется поддержка работы с временными рядами;
# - метод `fit` у всех алгоритмов позволяет гибко настраивать значения множества гиперпараметров, с помощью которых можно адаптировать обучение под конкретную задачу и добиться повышения точности результатов по сравнению с базовым вариантом обучения вида `fit(x_train, y_train)`;
# - существуют специальные возможности для управления производительностью обучения моделей и визуализации процесса обучения;
# - обученные модели можно сохранять для последующего использования без необходимости повторного обучения.
