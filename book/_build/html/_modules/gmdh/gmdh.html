
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gmdh.gmdh &#8212; GMDH book</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">GMDH book</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to your Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../markdown.html">
   Markdown Files
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../notebooks.html">
   Content with notebooks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../markdown-notebooks.html">
   Notebooks with MyST Markdown
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../api.html">
   gmdh package
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/executablebooks/jupyter-book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2F_modules/gmdh/gmdh.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for gmdh.gmdh</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">GMDH: Group method of data handling</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=c-extension-no-member, useless-parent-delegation, too-many-lines</span>

<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">docstring_inheritance</span> <span class="kn">import</span> <span class="n">NumpyDocstringInheritanceMeta</span>  <span class="c1"># pylint: disable=import-error</span>
<span class="kn">from</span> <span class="nn">gmdh</span> <span class="kn">import</span> <span class="n">_gmdh_core</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;time_series_transformation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;split_data&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Solver&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PolynomialType&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CriterionType&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Criterion&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ParallelCriterion&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SequentialCriterion&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Combi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Multi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Mia&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ria&quot;</span>
<span class="p">]</span>

<span class="k">class</span> <span class="nc">DocEnum</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum class for adding docstring to elements of inherited enumerations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Solver"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Solver">[docs]</a><span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="n">DocEnum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration for specifying the method of linear equations solving in GMDH models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">FAST</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Solver</span><span class="o">.</span><span class="n">FAST</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;Fast solving with low accuracy.&quot;</span>
    <span class="n">ACCURATE</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Solver</span><span class="o">.</span><span class="n">ACCURATE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;Slow solving with high accuracy.&#39;</span>
    <span class="n">BALANCED</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Solver</span><span class="o">.</span><span class="n">BALANCED</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;Balanced solving with medium speed and accuracy.&#39;</span></div>

<div class="viewcode-block" id="PolynomialType"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.PolynomialType">[docs]</a><span class="k">class</span> <span class="nc">PolynomialType</span><span class="p">(</span><span class="n">DocEnum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration for specifying the class of polynomials for GMDH models.</span>

<span class="sd">    It is the type of equations from which the set of solutions will be generated.</span>
<span class="sd">    Used for MIA and RIA models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LINEAR</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">PolynomialType</span><span class="o">.</span><span class="n">LINEAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> \
        <span class="s2">&quot;Using linear equations: w0 + w1*x1 + w2*x2.&quot;</span>
    <span class="n">LINEAR_COV</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">PolynomialType</span><span class="o">.</span><span class="n">LINEAR_COV</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> \
        <span class="s2">&quot;Using linear equations with covariation: w0 + w1*x1 + w2*x2 + w3*x1*x2.&quot;</span>
    <span class="n">QUADRATIC</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">PolynomialType</span><span class="o">.</span><span class="n">QUADRATIC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> \
        <span class="s2">&quot;Using quadratic equations: w0 + w1*x1 + w2*x2 + w3*x1*x2 + w4*x1^2 + w5*x2^2.&quot;</span></div>

<div class="viewcode-block" id="CriterionType"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.CriterionType">[docs]</a><span class="k">class</span> <span class="nc">CriterionType</span><span class="p">(</span><span class="n">DocEnum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration for specitying the criterion to select the optimum solution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">REGULARITY</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">SYM_REGULARITY</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">SYM_REGULARITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">STABILITY</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">STABILITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">SYM_STABILITY</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">SYM_STABILITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">UNBIASED_OUTPUTS</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">UNBIASED_OUTPUTS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">SYM_UNBIASED_OUTPUTS</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">SYM_UNBIASED_OUTPUTS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">UNBIASED_COEFFS</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">UNBIASED_COEFFS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">ABSOLUTE_NOISE_IMMUNITY</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">ABSOLUTE_NOISE_IMMUNITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
    <span class="n">SYM_ABSOLUTE_NOISE_IMMUNITY</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">SYM_ABSOLUTE_NOISE_IMMUNITY</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="Criterion"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Criterion">[docs]</a><span class="k">class</span> <span class="nc">Criterion</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing calculations for all possible single external criterions of GMDH models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    criterion_type : gmdh.CriterionType, default=gmdh.CriterionType.REGULARITY</span>
<span class="sd">        Element from `gmdh.CriterionType` enumeration specifying the type of external criterion</span>
<span class="sd">        that will be used to select the optimum solution during training GMDH model.</span>
<span class="sd">    solver : gmdh.Solver, default=gmdh.Solver.BALANCED</span>
<span class="sd">        Element from `gmdh.Solver` enumeration specifying the method of</span>
<span class="sd">        linear equations solving during training GMDH model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    criterion_type, solver : see Parameters</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    You can create `Criterion` object with parameters specifyied during initialization:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.Criterion(criterion_type=gmdh.CriterionType.STABILITY, \</span>
<span class="sd">solver=gmdh.Solver.FAST)</span>

<span class="sd">    Or you can create default `Criterion` object and then specify parameters using assignments:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.Criterion()</span>
<span class="sd">    &gt;&gt;&gt; criterion.criterion_type = gmdh.CriterionType.STABILITY</span>
<span class="sd">    &gt;&gt;&gt; criterion.solver = gmdh.Solver.FAST</span>

<span class="sd">    Displaying the current values of the arguments:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.Criterion()</span>
<span class="sd">    &gt;&gt;&gt; criterion.criterion_type</span>
<span class="sd">    &lt;CriterionType.REGULARITY: 0&gt;</span>
<span class="sd">    &gt;&gt;&gt; criterion.solver</span>
<span class="sd">    &lt;Solver.BALANCED: 2&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criterion_type</span><span class="o">=</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">Solver</span><span class="o">.</span><span class="n">BALANCED</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion_type</span><span class="p">,</span> <span class="n">CriterionType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">criterion_type</span><span class="si">}</span><span class="s2"> is not a &#39;CriterionType&#39; type object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">Solver</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2"> is not a &#39;Solver&#39; type object&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_criterion_type</span> <span class="o">=</span> <span class="n">criterion_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">solver</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">criterion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-function-docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_criterion_type</span>

    <span class="nd">@criterion_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">criterion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CriterionType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is not a &#39;CriterionType&#39; type object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_criterion_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-function-docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span>

    <span class="nd">@solver</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Solver</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is not a &#39;Solver&#39; type object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Criterion</span><span class="p">(</span>
        <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_criterion_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
        <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_solver</span><span class="o">.</span><span class="n">value</span><span class="p">))</span></div>

<div class="viewcode-block" id="ParallelCriterion"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.ParallelCriterion">[docs]</a><span class="k">class</span> <span class="nc">ParallelCriterion</span><span class="p">(</span><span class="n">Criterion</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing calculations for double parallel external criterions of GMDH models.</span>

<span class="sd">    A double parallel external criterion is a combination of two weighted single criterions.</span>
<span class="sd">    The resulting value is calculated by the formula:</span>
<span class="sd">    result = alpha * criterion1 + (1 - alpha) * criterion2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    criterion_type : gmdh.CriterionType, default=gmdh.CriterionType.REGULARITY</span>
<span class="sd">        Element from `gmdh.CriterionType` enumeration specifying the type of the first external</span>
<span class="sd">        criterion that will be used to select the optimum solution during training GMDH model.</span>
<span class="sd">    second_criterion_type : gmdh.CriterionType, default=gmdh.CriterionType.STABILITY</span>
<span class="sd">        Element from `gmdh.CriterionType` enumeration specifying the type of the second external</span>
<span class="sd">        criterion that will be used to select the optimum solution during training GMDH model.</span>
<span class="sd">    alpha : float, default=0.5</span>
<span class="sd">        Contribution of the first criterion to the combined parallel criterion.</span>
<span class="sd">        The Contribution of the second criterion will be equal to (1 - alpha).</span>
<span class="sd">        Value must be in the (0, 1) range.</span>
<span class="sd">    solver : gmdh.Solver, default=gmdh.Solver.BALANCED</span>
<span class="sd">        Element from `gmdh.Solver` enumeration specifying the method of</span>
<span class="sd">        linear equations solving during training GMDH model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    criterion_type, second_criterion_type, alpha, solver : see Parameters</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    You can create `ParallelCriterion` object with parameters specifyied during initialization:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.ParallelCriterion(criterion_type=gmdh.CriterionType.STABILITY, \</span>
<span class="sd">second_criterion_type=gmdh.CriterionType.REGULARITY, alpha=0.8, solver=gmdh.Solver.FAST)</span>

<span class="sd">    Or you can create default `ParallelCriterion` object</span>
<span class="sd">    and then specify parameters using assignments:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.ParallelCriterion()</span>
<span class="sd">    &gt;&gt;&gt; criterion.criterion_type = gmdh.CriterionType.STABILITY</span>
<span class="sd">    &gt;&gt;&gt; criterion.second_criterion_type = gmdh.CriterionType.REGULARITY</span>
<span class="sd">    &gt;&gt;&gt; criterion.alpha = 0.8</span>
<span class="sd">    &gt;&gt;&gt; criterion.solver = gmdh.Solver.FAST</span>

<span class="sd">    Displaying the current values of the arguments:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.ParallelCriterion()</span>
<span class="sd">    &gt;&gt;&gt; criterion.criterion_type</span>
<span class="sd">    &lt;CriterionType.REGULARITY: 0&gt;</span>
<span class="sd">    &gt;&gt;&gt; criterion.second_criterion_type</span>
<span class="sd">    &lt;CriterionType.STABILITY: 2&gt;</span>
<span class="sd">    &gt;&gt;&gt; criterion.alpha</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; criterion.solver</span>
<span class="sd">    &lt;Solver.BALANCED: 2&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">criterion_type</span><span class="o">=</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">,</span>
        <span class="n">second_criterion_type</span><span class="o">=</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">STABILITY</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">Solver</span><span class="o">.</span><span class="n">BALANCED</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">criterion_type</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">second_criterion_type</span><span class="p">,</span> <span class="n">CriterionType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">second_criterion_type</span><span class="si">}</span><span class="s2"> is not a &#39;CriterionType&#39; type object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2"> is not a float&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha value must be in the (0, 1) range&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span> <span class="o">=</span> <span class="n">second_criterion_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">second_criterion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-function-docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span>

    <span class="nd">@second_criterion_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">second_criterion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CriterionType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is not a &#39;CriterionType&#39; type object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-function-docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span>

    <span class="nd">@alpha</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is not a float&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha value must be in the (0, 1) range&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">ParallelCriterion</span><span class="p">(</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_criterion_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">,</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_solver</span><span class="o">.</span><span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="SequentialCriterion"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.SequentialCriterion">[docs]</a><span class="k">class</span> <span class="nc">SequentialCriterion</span><span class="p">(</span><span class="n">Criterion</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing calculations for double sequential external criterions of GMDH models.</span>

<span class="sd">    A double sequential external criterion is a combination of two single criterion</span>
<span class="sd">    that are applied one after the other. The first one is used to calculate criterion values</span>
<span class="sd">    for all solutions. The second one is used to recalculate criterion values for</span>
<span class="sd">    several solutions with the best values of the first criterion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    criterion_type : gmdh.CriterionType, default=gmdh.CriterionType.REGULARITY</span>
<span class="sd">        Element from `gmdh.CriterionType` enumeration specifying the type of the first external</span>
<span class="sd">        criterion that will be used to select the optimum solution during training GMDH model.</span>
<span class="sd">    second_criterion_type : gmdh.CriterionType, default=gmdh.CriterionType.STABILITY</span>
<span class="sd">        Element from `gmdh.CriterionType` enumeration specifying the type of the second external</span>
<span class="sd">        criterion that will be used to recalcuate criterion values for solutions</span>
<span class="sd">        with the best first criterion values.</span>
<span class="sd">    solver : gmdh.Solver, default=gmdh.Solver.BALANCED</span>
<span class="sd">        Element from `gmdh.Solver` enumeration specifying the method of</span>
<span class="sd">        linear equations solving during training GMDH model.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    criterion_type, second_criterion_type, solver : see Parameters</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    You can create `SequentialCriterion` object with parameters specifyied during initialization:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.SequentialCriterion(criterion_type=gmdh.CriterionType.STABILITY, \</span>
<span class="sd">second_criterion_type=gmdh.CriterionType.REGULARITY, solver=gmdh.Solver.FAST)</span>

<span class="sd">    Or you can create default `SequentialCriterion` object</span>
<span class="sd">    and then specify parameters using assignments:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.SequentialCriterion()</span>
<span class="sd">    &gt;&gt;&gt; criterion.criterion_type = gmdh.CriterionType.STABILITY</span>
<span class="sd">    &gt;&gt;&gt; criterion.second_criterion_type = gmdh.CriterionType.REGULARITY</span>
<span class="sd">    &gt;&gt;&gt; criterion.solver = gmdh.Solver.FAST</span>

<span class="sd">    Displaying the current values of the arguments:</span>

<span class="sd">    &gt;&gt;&gt; criterion = gmdh.SequentialCriterion()</span>
<span class="sd">    &gt;&gt;&gt; criterion.criterion_type</span>
<span class="sd">    &lt;CriterionType.REGULARITY: 0&gt;</span>
<span class="sd">    &gt;&gt;&gt; criterion.second_criterion_type</span>
<span class="sd">    &lt;CriterionType.STABILITY: 2&gt;</span>
<span class="sd">    &gt;&gt;&gt; criterion.solver</span>
<span class="sd">    &lt;Solver.BALANCED: 2&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">criterion_type</span><span class="o">=</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">,</span>
        <span class="n">second_criterion_type</span><span class="o">=</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">STABILITY</span><span class="p">,</span>
        <span class="n">solver</span><span class="o">=</span><span class="n">Solver</span><span class="o">.</span><span class="n">BALANCED</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">criterion_type</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">second_criterion_type</span><span class="p">,</span> <span class="n">CriterionType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">second_criterion_type</span><span class="si">}</span><span class="s2"> is not a &#39;CriterionType&#39; type object&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span> <span class="o">=</span> <span class="n">second_criterion_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">second_criterion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-function-docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span>

    <span class="nd">@second_criterion_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">second_criterion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CriterionType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> is not a &#39;CriterionType&#39; type object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_get_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>  <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">SequentialCriterion</span><span class="p">(</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_criterion_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">CriterionType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_criterion_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_solver</span><span class="o">.</span><span class="n">value</span><span class="p">))</span></div>

<span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">NumpyDocstringInheritanceMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Meta class from which the abstract Model class is inherited</span>
<span class="sd">    to provide posiibility avoiding writing duplicated docstrings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class that provides model interfaces and</span>
<span class="sd">    the implementation of all methods except fit.</span>
<span class="sd">    The methods contain only docstring information, which is the same for all models.</span>
<span class="sd">    The different parts are written in the methods of the child classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            2D array containing numeric training data.</span>
<span class="sd">            Rows are data samples, columns are features or lags.</span>
<span class="sd">        y : array_like</span>
<span class="sd">            1D array containg target numeric values for the training data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        predict : Using fitted model to make predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make predictions based on the optimal solution found during the fitting process.</span>

<span class="sd">        This method can be used for both regular datasets with features</span>
<span class="sd">        and time-series datasets. For time series it is necessary to specify `lags` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            1D or 2D array containing numeric test data.</span>
<span class="sd">            If 2D array is used then rows are data samples, columns are features.</span>
<span class="sd">            If 1D array is used then the array should contain time series values and</span>
<span class="sd">            the array size must be equal to the lags number of the used training data.</span>
<span class="sd">        lags : int, default=None</span>
<span class="sd">            If `X` represents the time series data then lags parameter is the number</span>
<span class="sd">            of sequential values that will be predicted. If `X` isn&#39;t the time series</span>
<span class="sd">            the lags parameter must be None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predictions : array_like</span>
<span class="sd">            1D array containing precited values for given `X` data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_best_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getting a string representation of the formula of the best polynomial.</span>

<span class="sd">        Using this method you can see the polynomial that was constructed</span>
<span class="sd">        during the fitting process and will be used for predictions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        polynomial : str</span>
<span class="sd">            Polynomial of the fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">get_best_polynomial</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saving fitted model to the file.</span>

<span class="sd">        Using this method tou can save all the necessary information about structure</span>
<span class="sd">        and parameters of the fitted model in JSON format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            Path to the file to save the model.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        load : Loading pre-trained model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loading model from the file</span>

<span class="sd">        Using this method you can load a pre-trained model to make predictions without fitting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            Path to the file for loading the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Combi"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Combi">[docs]</a><span class="k">class</span> <span class="nc">Combi</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing combinatorial GMDH algorithm.</span>

<span class="sd">    It is the basic GMDH algorithm that checks all possible combinations</span>
<span class="sd">    from simple to complex ones. Each combination is a linear function.\n</span>
<span class="sd">    Combinations at the first level: y = w0 + w1*x1.\n</span>
<span class="sd">    Combinations at the second level: y = w0 + w1*x1 + w2*x2.\n</span>
<span class="sd">    Combinations at the N-th level: y = w0 + w1*x1 + w2*x2 + ... + wn*xn.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Combi</span><span class="p">())</span>

<div class="viewcode-block" id="Combi.fit"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Combi.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="n">Criterion</span><span class="p">(</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">),</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="n">p_average</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fitting the Combi model to find the best solution.</span>

<span class="sd">        Using the input training `X` and `y` data the Combi model looks for the optimal solution</span>
<span class="sd">        from linear functions and stops if the errors start to grow.</span>
<span class="sd">        The training process can be configured for specific purposes</span>
<span class="sd">        using hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criterion : gmdh.Criterion, default=gmdh.Criterion(gmdh.CriterionType.REGULARITY)</span>
<span class="sd">            External criterion is a function or specific combination of functions</span>
<span class="sd">            for solutions evaluation and choosing the best one.</span>
<span class="sd">        test_size : float, default=0.5</span>
<span class="sd">            Proportion of the input data to include in the internal test set</span>
<span class="sd">            that will be used only to calculate external criterion value.</span>
<span class="sd">            Value must be in the (0, 1) range.</span>
<span class="sd">        p_average : int, default=1</span>
<span class="sd">            Specifying the number of the best combinations for calculation</span>
<span class="sd">            the mean error value at each level.</span>
<span class="sd">        n_jobs : int, default=1</span>
<span class="sd">            The number of threads that will be used for calculations.</span>
<span class="sd">            If n_jobs=-1 the maximum possible threads will be used.</span>
<span class="sd">        verbose : {0, 1}, default=0</span>
<span class="sd">            If verbose=1 then the progress bars and additional information</span>
<span class="sd">            will be displayed during the model fitting.</span>
<span class="sd">            If verbose=0 there will be no information to display.</span>
<span class="sd">        limit : float, default=0</span>
<span class="sd">            If the error value at the end of the level decreases by less then limit value</span>
<span class="sd">            compared to the previous level the training process will stop.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Combi</span>
<span class="sd">            Fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">.</span><span class="n">_get_core</span><span class="p">(),</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">p_average</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Combi.predict"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Combi.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Creating data for fitting the model.</span>
<span class="sd">        The `X` array contains pairs of numbers, and</span>
<span class="sd">        the `y` array contains the corresponding sums of two numbers:</span>

<span class="sd">        &gt;&gt;&gt; X = [[1, 2], [3, 2], [7, 0], [5, 5], [1, 4], [2, 6]]</span>
<span class="sd">        &gt;&gt;&gt; y = [sum(row) for row in X]  # [3, 5, 7, 10, 5, 8]</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y, test_size=0.33)</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([5., 8.])</span>

<span class="sd">        Fitting the model and making predictions:</span>

<span class="sd">        &gt;&gt;&gt; model = gmdh.Combi()</span>
<span class="sd">        &gt;&gt;&gt; model.fit(x_train, y_train)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Combi object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model.predict(x_test)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([5., 8.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span></div>

<div class="viewcode-block" id="Combi.get_best_polynomial"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Combi.get_best_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">get_best_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Fitting the Combi model using Fibonacci series:</span>

<span class="sd">        &gt;&gt;&gt; X, y = gmdh.time_series_transformation([1, 1, 2, 3, 5, 8, 13, 21], lags=2)</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y, test_size=0.25)</span>
<span class="sd">        &gt;&gt;&gt; model = gmdh.Combi()</span>
<span class="sd">        &gt;&gt;&gt; model.fit(x_train, y_train).predict(x_test)</span>
<span class="sd">        array([13., 21.])</span>
<span class="sd">        &gt;&gt;&gt; model.get_best_polynomial()</span>
<span class="sd">        &#39;y = x1 + x2&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_best_polynomial</span><span class="p">()</span></div>

<div class="viewcode-block" id="Combi.save"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Combi.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Combi</span>
<span class="sd">            Combi model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Combi.load"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Combi.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Combi</span>
<span class="sd">            Combi model loaded from the file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Teaching the model to sum 2 numbers, then making predictions</span>
<span class="sd">        and saving model to the JSON file:</span>

<span class="sd">        &gt;&gt;&gt; model1 = gmdh.Combi()</span>
<span class="sd">        &gt;&gt;&gt; model1.fit(X=[[0, 2], [7, 4], [5, 5], [9, 12]], y=[2, 11, 10, 21])  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Combi object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; model1.predict([[4, 3], [1, 11]])</span>
<span class="sd">        array([ 7., 12.])</span>
<span class="sd">        &gt;&gt;&gt; model1.save(&#39;model1.json&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Combi object at 0x...&gt;</span>

<span class="sd">        Loading pre-trained model and making predictions without fitting:</span>

<span class="sd">        &gt;&gt;&gt; model2 = gmdh.Combi()</span>
<span class="sd">        &gt;&gt;&gt; model2.load(&#39;model1.json&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Combi object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; model2.predict([[4, 3], [1, 11]])</span>
<span class="sd">        array([ 7., 12.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Multi"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Multi">[docs]</a><span class="k">class</span> <span class="nc">Multi</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing combinatorial selection Multi algorithm.</span>

<span class="sd">    This algorithm is an improvement of Combi algorithm. It works much faster</span>
<span class="sd">    but doesn&#39;t check all possible combinations.</span>
<span class="sd">    The idea of Multi algorithm is to select several best combinations</span>
<span class="sd">    of the input features (or lags) at each level and then combine this combinations</span>
<span class="sd">    with one of the other unused features (or lags) at the next level.</span>
<span class="sd">    As in the Combi algorithm, each combination in Multi is a linear function.\n</span>
<span class="sd">    Let there be 4 features in total (x1, x2, x3, x4)</span>
<span class="sd">    and the best combinations at the first level are:\n</span>
<span class="sd">    y = f(x2) and y = f(x3), where f - linear polynomail.\n</span>
<span class="sd">    Then at the second level Multi will consider combinations:\n</span>
<span class="sd">    y = f(x2, x1)\n</span>
<span class="sd">    y = f(x2, x3)\n</span>
<span class="sd">    y = f(x2, x4)\n</span>
<span class="sd">    y = f(x3, x1)\n</span>
<span class="sd">    y = f(x3, x4)\n</span>
<span class="sd">    At each level, one new variable will be added to the best combinations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Multi</span><span class="p">())</span>

<div class="viewcode-block" id="Multi.fit"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Multi.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="n">Criterion</span><span class="p">(</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">),</span> <span class="n">k_best</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">p_average</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fitting the Multi model to find the best solution.</span>

<span class="sd">        Using the input training `X` and `y` data the Multi model looks for the optimal solution</span>
<span class="sd">        from linear functions and stops if the errors start to grow.</span>
<span class="sd">        The training process can be configured for specific purposes</span>
<span class="sd">        using hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criterion : gmdh.Criterion, default=gmdh.Criterion(gmdh.CriterionType.REGULARITY)</span>
<span class="sd">            External criterion is a function or specific combination of functions</span>
<span class="sd">            for solutions evaluation and choosing the best one.</span>
<span class="sd">        k_best : int, default=1</span>
<span class="sd">            The number of best combinations at each level that will be combined</span>
<span class="sd">            with other unused features (or lags) at the next level.</span>
<span class="sd">        test_size : float, default=0.5</span>
<span class="sd">            Proportion of the input data to include in the internal test set</span>
<span class="sd">            that will be used only to calculate external criterion value.</span>
<span class="sd">            Value must be in the (0, 1) range.</span>
<span class="sd">        p_average : int, default=1</span>
<span class="sd">            Specifying the number of the best combinations for calculation</span>
<span class="sd">            the mean error value at each level.</span>
<span class="sd">        n_jobs : int, default=1</span>
<span class="sd">            The number of threads that will be used for calculations.</span>
<span class="sd">            If n_jobs=-1 the maximum possible threads will be used.</span>
<span class="sd">        verbose : {0, 1}, default=0</span>
<span class="sd">            If verbose=1 then the progress bars and additional information</span>
<span class="sd">            will be displayed during the model fitting.</span>
<span class="sd">            If verbose=0 there will be no information to display.</span>
<span class="sd">        limit : float, default=0</span>
<span class="sd">            If the error value at the end of the level decreases by less then limit value</span>
<span class="sd">            compared to the previous level the training process will stop.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Multi</span>
<span class="sd">            Fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">.</span><span class="n">_get_core</span><span class="p">(),</span> <span class="n">k_best</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">p_average</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Multi.predict"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Multi.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Creating data for fitting the model.</span>
<span class="sd">        The `X` array contains pairs of numbers, and</span>
<span class="sd">        the `y` array contains the corresponding sums of two numbers:</span>

<span class="sd">        &gt;&gt;&gt; X = [[1, 2], [3, 2], [7, 0], [5, 5], [1, 4], [2, 6]]</span>
<span class="sd">        &gt;&gt;&gt; y = [sum(row) for row in X]  # [3, 5, 7, 10, 5, 8]</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y, test_size=0.33)</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([5., 8.])</span>

<span class="sd">        Fitting the model and making predictions:</span>

<span class="sd">        &gt;&gt;&gt; model = gmdh.Multi()</span>
<span class="sd">        &gt;&gt;&gt; model.fit(x_train, y_train)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Multi object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model.predict(x_test)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([5., 8.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span></div>

<div class="viewcode-block" id="Multi.get_best_polynomial"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Multi.get_best_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">get_best_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Fitting the Multi model using Fibonacci series:</span>

<span class="sd">        &gt;&gt;&gt; X, y = gmdh.time_series_transformation([1, 1, 2, 3, 5, 8, 13, 21], lags=2)</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y, test_size=0.25)</span>
<span class="sd">        &gt;&gt;&gt; model = gmdh.Multi()</span>
<span class="sd">        &gt;&gt;&gt; model.fit(x_train, y_train).predict(x_test)</span>
<span class="sd">        array([13., 21.])</span>
<span class="sd">        &gt;&gt;&gt; model.get_best_polynomial()</span>
<span class="sd">        &#39;y = x1 + x2&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_best_polynomial</span><span class="p">()</span></div>

<div class="viewcode-block" id="Multi.save"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Multi.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Multi</span>
<span class="sd">            Multi model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Multi.load"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Multi.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Multi</span>
<span class="sd">            Multi model loaded from the file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Teaching the model to sum 2 numbers, then making predictions</span>
<span class="sd">        and saving model to the JSON file:</span>

<span class="sd">        &gt;&gt;&gt; model1 = gmdh.Multi()</span>
<span class="sd">        &gt;&gt;&gt; model1.fit(X=[[0, 2], [7, 4], [5, 5], [9, 12]], y=[2, 11, 10, 21])  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Multi object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; model1.predict([[4, 3], [1, 11]])</span>
<span class="sd">        array([ 7., 12.])</span>
<span class="sd">        &gt;&gt;&gt; model1.save(&#39;model1.json&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Multi object at 0x...&gt;</span>

<span class="sd">        Loading pre-trained model and making predictions without fitting:</span>

<span class="sd">        &gt;&gt;&gt; model2 = gmdh.Multi()</span>
<span class="sd">        &gt;&gt;&gt; model2.load(&#39;model1.json&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Multi object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; model2.predict([[4, 3], [1, 11]])</span>
<span class="sd">        array([ 7., 12.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Mia"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Mia">[docs]</a><span class="k">class</span> <span class="nc">Mia</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing multilayered iterative Mia algorithm.</span>

<span class="sd">    In Mia algorithm combinations are polynomails f(xi, xj).</span>
<span class="sd">    These polynomials can be non-linear. The type of polynomials</span>
<span class="sd">    can be specifying using `polynomial_type` parameter.</span>

<span class="sd">    Several best combinations are selected at each level.</span>
<span class="sd">    Then еach model is considered as a new variable.</span>
<span class="sd">    Each pair of these new variables generates</span>
<span class="sd">    a new variable when moving to the next level.</span>

<span class="sd">    Let there be 4 features in total (x1, x2, x3, x4)</span>
<span class="sd">    and the best combinations at the first level are:\n</span>
<span class="sd">    y = f1(x1, x2)\n</span>
<span class="sd">    y = f2(x1, x3)\n</span>
<span class="sd">    y = f3(x2, x4)\n</span>
<span class="sd">    Then at the second level Mia will consider combinations:\n</span>
<span class="sd">    y = f4(f1, f2)\n</span>
<span class="sd">    y = f5(f1, f3)\n</span>
<span class="sd">    y = f6(f2, f3)\n</span>
<span class="sd">    At each level, new combinations are constructed from the best polynomials of the last level.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Mia</span><span class="p">())</span>

<div class="viewcode-block" id="Mia.fit"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Mia.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="n">Criterion</span><span class="p">(</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">),</span> <span class="n">k_best</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">polynomial_type</span><span class="o">=</span><span class="n">PolynomialType</span><span class="o">.</span><span class="n">QUADRATIC</span><span class="p">,</span>
        <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">p_average</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fitting the Mia model to find the best solution.</span>

<span class="sd">        Using the input training `X` and `y` data the Mia model looks for the optimal solution</span>
<span class="sd">        from polynomials constructed from `polynomial_type` basic polynomials</span>
<span class="sd">        and stops if the errors start to grow. The training process can be configured</span>
<span class="sd">        for specific purposes using hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criterion : gmdh.Criterion, default=gmdh.Criterion(gmdh.CriterionType.REGULARITY)</span>
<span class="sd">            External criterion is a function or specific combination of functions</span>
<span class="sd">            for solutions evaluation and choosing the best one.</span>
<span class="sd">        k_best : int, default=3</span>
<span class="sd">            The number of best combinations at each level that will be combined</span>
<span class="sd">            with other unused features (or lags) at the next level.</span>
<span class="sd">            The minimum allowed value is 3.</span>
<span class="sd">        test_size : float, default=0.5</span>
<span class="sd">            Proportion of the input data to include in the internal test set</span>
<span class="sd">            that will be used only to calculate external criterion value.</span>
<span class="sd">            Value must be in the (0, 1) range.</span>
<span class="sd">        polynomial_type : gmdh.PolynomialType, default=gmdh.PolynomialType.QUADRATIC</span>
<span class="sd">            Specifying the type of polynomials that will be used to construct the final polynomial.</span>
<span class="sd">        p_average : int, default=1</span>
<span class="sd">            Specifying the number of the best combinations for calculation</span>
<span class="sd">            the mean error value at each level.</span>
<span class="sd">        n_jobs : int, default=1</span>
<span class="sd">            The number of threads that will be used for calculations.</span>
<span class="sd">            If n_jobs=-1 the maximum possible threads will be used.</span>
<span class="sd">        verbose : {0, 1}, default=0</span>
<span class="sd">            If verbose=1 then the progress bars and additional information</span>
<span class="sd">            will be displayed during the model fitting.</span>
<span class="sd">            If verbose=0 there will be no information to display.</span>
<span class="sd">        limit : float, default=0</span>
<span class="sd">            If the error value at the end of the level decreases by less then limit value</span>
<span class="sd">            compared to the previous level the training process will stop.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Mia</span>
<span class="sd">            Fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">.</span><span class="n">_get_core</span><span class="p">(),</span> <span class="n">k_best</span><span class="p">,</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">PolynomialType</span><span class="p">(</span><span class="n">polynomial_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">test_size</span><span class="p">,</span>
            <span class="n">p_average</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Mia.predict"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Mia.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Time series data preparations:</span>

<span class="sd">        &gt;&gt;&gt; X, y = gmdh.time_series_transformation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], lags=3)</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">        &gt;&gt;&gt; x_test</span>
<span class="sd">        array([[ 7.,  8.,  9.],</span>
<span class="sd">               [ 8.,  9., 10.]])</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([10., 11.])</span>

<span class="sd">        Fitting the model and making predictions 5 steps ahead (lags=5)</span>
<span class="sd">        based only on the first row of `x_test` data:</span>

<span class="sd">        &gt;&gt;&gt; model = gmdh.Mia()</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model.fit(x_train, y_train).predict(x_test[0], lags=5)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([10., 11., 12., 13., 14.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mia.get_best_polynomial"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Mia.get_best_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">get_best_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Creating data for fitting the model.</span>
<span class="sd">        The `X` matrix contains array of 4 numbers and</span>
<span class="sd">        the `y` array contains results of the function</span>
<span class="sd">        f(x1, x2, x3, x4) = x1^2 + x4^2 + 2*x1*x4:</span>

<span class="sd">        &gt;&gt;&gt; X = [[0, 1, 2, 3],</span>
<span class="sd">        ...      [3, 4, 3, 2],</span>
<span class="sd">        ...      [2, 5, 1, 0],</span>
<span class="sd">        ...      [1, 1, 5, 6],</span>
<span class="sd">        ...      [2, 3, 1, 4],</span>
<span class="sd">        ...      [2, 6, 0, 1],</span>
<span class="sd">        ...      [3, 4, 2, 5]]</span>
<span class="sd">        &gt;&gt;&gt; y = [row[0]**2 + 2*row[0]*row[3] + row[3]**2 for row in X]  # [9, 25, 4, 49, 36, 9, 64]</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([64.])</span>

<span class="sd">        Fitting the model, making predictions and printing the best polynomial:</span>

<span class="sd">        &gt;&gt;&gt; model = gmdh.Mia()</span>
<span class="sd">        &gt;&gt;&gt; model.fit(x_train, y_train)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Mia object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model.predict(x_test)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([64.])</span>
<span class="sd">        &gt;&gt;&gt; model.get_best_polynomial()</span>
<span class="sd">        &#39;y = 2*x1*x4 + x1^2 + x4^2&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_best_polynomial</span><span class="p">()</span></div>

<div class="viewcode-block" id="Mia.save"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Mia.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Mia</span>
<span class="sd">            Mia model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mia.load"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Mia.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Mia</span>
<span class="sd">            Mia model loaded from the file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Time series data preparations, fitting the Mia model,</span>
<span class="sd">        making predictions and saving model to the JSON file:</span>

<span class="sd">        &gt;&gt;&gt; X, y = gmdh.time_series_transformation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], lags=3)</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([10., 11.])</span>
<span class="sd">        &gt;&gt;&gt; model1 = gmdh.Mia()</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model1.fit(x_train, y_train).predict(x_test)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([10., 11.])</span>
<span class="sd">        &gt;&gt;&gt; model1.save(&quot;model1.json&quot;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Mia object at 0x...&gt;</span>

<span class="sd">        Loading pre-trained model and making predictions without fitting:</span>

<span class="sd">        &gt;&gt;&gt; model2 = gmdh.Mia()</span>
<span class="sd">        &gt;&gt;&gt; model2.load(&#39;model1.json&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Mia object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; model2.predict(x_test)</span>
<span class="sd">        array([10., 11.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Ria"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Ria">[docs]</a><span class="k">class</span> <span class="nc">Ria</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing relaxation iterative Ria algorithm.</span>

<span class="sd">    This algorithm is an improvement of Mia algorithm.</span>
<span class="sd">    Fewer combinations are considered at each level.</span>
<span class="sd">    Algorithm combinations are polynomails f(xi, xj).</span>
<span class="sd">    These polynomials can be non-linear. The type of polynomials</span>
<span class="sd">    can be specifying using `polynomial_type` parameter.</span>

<span class="sd">    Several best combinations are selected at each level.</span>
<span class="sd">    Then еach model is considered as a new variable and</span>
<span class="sd">    these new variables are combined with the original variables</span>
<span class="sd">    to generate new variables when moving to the next level.</span>

<span class="sd">    Let there be 3 features in total (x1, x2, x3)</span>
<span class="sd">    and the best combinations at the first level are:\n</span>
<span class="sd">    y = f1(x1, x2)\n</span>
<span class="sd">    y = f2(x1, x3)\n</span>
<span class="sd">    Then at the second level Ria will consider combinations:\n</span>
<span class="sd">    y = f3(f1, x1)\n</span>
<span class="sd">    y = f4(f1, x2)\n</span>
<span class="sd">    y = f5(f1, x3)\n</span>
<span class="sd">    y = f6(f2, x1)\n</span>
<span class="sd">    y = f7(f2, x2)\n</span>
<span class="sd">    y = f8(f2, x3)\n</span>
<span class="sd">    At each level, new combinations are constructed from the best polynomials</span>
<span class="sd">    of the last level and the original variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_gmdh_core</span><span class="o">.</span><span class="n">Ria</span><span class="p">())</span>

<div class="viewcode-block" id="Ria.fit"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Ria.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="n">Criterion</span><span class="p">(</span><span class="n">CriterionType</span><span class="o">.</span><span class="n">REGULARITY</span><span class="p">),</span> <span class="n">k_best</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">polynomial_type</span><span class="o">=</span><span class="n">PolynomialType</span><span class="o">.</span><span class="n">QUADRATIC</span><span class="p">,</span>
        <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">p_average</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fitting the Ria model to find the best solution.</span>

<span class="sd">        Using the input training `X` and `y` data the Ria model looks for the optimal solution</span>
<span class="sd">        from polynomials constructed from `polynomial_type` basic polynomials</span>
<span class="sd">        and stops if the errors start to grow. The training process can be configured</span>
<span class="sd">        for specific purposes using hyperparameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criterion : gmdh.Criterion, default=gmdh.Criterion(gmdh.CriterionType.REGULARITY)</span>
<span class="sd">            External criterion is a function or specific combination of functions</span>
<span class="sd">            for solutions evaluation and choosing the best one.</span>
<span class="sd">        k_best : int, default=1</span>
<span class="sd">            The number of best combinations at each level that will be combined</span>
<span class="sd">            with other unused features (or lags) at the next level.</span>
<span class="sd">        test_size : float, default=0.5</span>
<span class="sd">            Proportion of the input data to include in the internal test set</span>
<span class="sd">            that will be used only to calculate external criterion value.</span>
<span class="sd">            Value must be in the (0, 1) range.</span>
<span class="sd">        polynomial_type : gmdh.PolynomialType, default=gmdh.PolynomialType.QUADRATIC</span>
<span class="sd">            Specifying the type of polynomials that will be used to construct the final polynomial.</span>
<span class="sd">        p_average : int, default=1</span>
<span class="sd">            Specifying the number of the best combinations for calculation</span>
<span class="sd">            the mean error value at each level.</span>
<span class="sd">        n_jobs : int, default=1</span>
<span class="sd">            The number of threads that will be used for calculations.</span>
<span class="sd">            If n_jobs=-1 the maximum possible threads will be used.</span>
<span class="sd">        verbose : {0, 1}, default=0</span>
<span class="sd">            If verbose=1 then the progress bars and additional information</span>
<span class="sd">            will be displayed during the model fitting.</span>
<span class="sd">            If verbose=0 there will be no information to display.</span>
<span class="sd">        limit : float, default=0</span>
<span class="sd">            If the error value at the end of the level decreases by less then limit value</span>
<span class="sd">            compared to the previous level the training process will stop.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Ria</span>
<span class="sd">            Fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">criterion</span><span class="o">.</span><span class="n">_get_core</span><span class="p">(),</span> <span class="n">k_best</span><span class="p">,</span>
            <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">PolynomialType</span><span class="p">(</span><span class="n">polynomial_type</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">test_size</span><span class="p">,</span>
            <span class="n">p_average</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Ria.predict"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Ria.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Time series data preparations:</span>

<span class="sd">        &gt;&gt;&gt; X, y = gmdh.time_series_transformation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], lags=3)</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">        &gt;&gt;&gt; x_test</span>
<span class="sd">        array([[ 7.,  8.,  9.],</span>
<span class="sd">               [ 8.,  9., 10.]])</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([10., 11.])</span>

<span class="sd">        Fitting the model and making predictions 5 steps ahead (lags=5)</span>
<span class="sd">        based only on the first row of `x_test` data:</span>

<span class="sd">        &gt;&gt;&gt; model = gmdh.Ria()</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model.fit(x_train, y_train).predict(x_test[0], lags=5)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([10., 11., 12., 13., 14.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ria.get_best_polynomial"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Ria.get_best_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">get_best_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Creating data for fitting the model.</span>
<span class="sd">        The `X` matrix contains array of 3 numbers and</span>
<span class="sd">        the `y` array contains results of the function</span>
<span class="sd">        f(x1, x2, x3) = x1^2 + 10*x2^2 + 80:</span>

<span class="sd">        &gt;&gt;&gt; X = [[0, 1, 1],</span>
<span class="sd">        ...      [3, 5, 4],</span>
<span class="sd">        ...      [2, 1, 3],</span>
<span class="sd">        ...      [1, 1, 4],</span>
<span class="sd">        ...      [2, 2, 1],</span>
<span class="sd">        ...      [2, 6, 0],</span>
<span class="sd">        ...      [3, 3, 4]]</span>
<span class="sd">        &gt;&gt;&gt; y = [row[0]**2 + 10 * row[1]**2 + 80 for row in X]  # [90, 339, 94, 91, 124, 444, 179]</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([179.])</span>

<span class="sd">        Fitting the model, making predictions and printing the best polynomial:</span>

<span class="sd">        &gt;&gt;&gt; model = gmdh.Ria()</span>
<span class="sd">        &gt;&gt;&gt; model.fit(x_train, y_train)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Ria object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model.predict(x_test)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([179.])</span>
<span class="sd">        &gt;&gt;&gt; model.get_best_polynomial()</span>
<span class="sd">        &#39;y = x1^2 + 10*x2^2 + 80&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_best_polynomial</span><span class="p">()</span></div>

<div class="viewcode-block" id="Ria.save"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Ria.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Ria</span>
<span class="sd">            Ria model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ria.load"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.Ria.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Ria</span>
<span class="sd">            Ria model loaded from the file.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Time series data preparations, fitting the Ria model,</span>
<span class="sd">        making predictions and saving model to the JSON file:</span>

<span class="sd">        &gt;&gt;&gt; X, y = gmdh.time_series_transformation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], lags=3)</span>
<span class="sd">        &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">        &gt;&gt;&gt; y_test</span>
<span class="sd">        array([10., 11.])</span>
<span class="sd">        &gt;&gt;&gt; model1 = gmdh.Ria()</span>
<span class="sd">        &gt;&gt;&gt; y_pred = model1.fit(x_train, y_train).predict(x_test)</span>
<span class="sd">        &gt;&gt;&gt; y_pred</span>
<span class="sd">        array([10., 11.])</span>
<span class="sd">        &gt;&gt;&gt; model1.save(&quot;model1.json&quot;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Ria object at 0x...&gt;</span>

<span class="sd">        Loading pre-trained model and making predictions without fitting:</span>

<span class="sd">        &gt;&gt;&gt; model2 = gmdh.Ria()</span>
<span class="sd">        &gt;&gt;&gt; model2.load(&#39;model1.json&#39;)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;gmdh.gmdh.Ria object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; model2.predict(x_test)</span>
<span class="sd">        array([10., 11.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="time_series_transformation"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.time_series_transformation">[docs]</a><span class="k">def</span> <span class="nf">time_series_transformation</span><span class="p">(</span><span class="n">time_series</span><span class="p">,</span> <span class="n">lags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converting a time series into `X` and `y` data.</span>

<span class="sd">    Using this method, you can transform one-dimensional array</span>
<span class="sd">    with time series data into two arrays (`X` and `y` data) according</span>
<span class="sd">    to the required number of lags.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_series : array_like</span>
<span class="sd">        1D array containing original time series.</span>
<span class="sd">    lags : int</span>
<span class="sd">        The number of lags. Acceptable values are from 1 to `time_series.size()` - 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : tuple</span>
<span class="sd">        A tuple whose items are arrays of `X` and `y` data</span>
<span class="sd">        constructed from a time series.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x, y = gmdh.time_series_transformation([1, 2, 3, 4, 5, 6], lags=3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[1., 2., 3.],</span>
<span class="sd">           [2., 3., 4.],</span>
<span class="sd">           [3., 4., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([4., 5., 6.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">time_series_transformation</span><span class="p">(</span><span class="n">time_series</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span></div>

<div class="viewcode-block" id="split_data"><a class="viewcode-back" href="../../api.html#gmdh.gmdh.split_data">[docs]</a><span class="k">def</span> <span class="nf">split_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splitting data into train and test subsets.</span>

<span class="sd">    Using this method, you can prepare your data for further work</span>
<span class="sd">    with machine learning models by dividing it into training and test sets.</span>
<span class="sd">    The proportions of the subsets and the data shuffling</span>
<span class="sd">    can be customized according to your choice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array_like</span>
<span class="sd">        2D array containing numeric values.</span>
<span class="sd">        Rows are data samples, columns are features or lags.</span>
<span class="sd">    y : array_lile</span>
<span class="sd">        1D array containg target numeric values.</span>
<span class="sd">    test_size : float, default=0.2</span>
<span class="sd">        Proportion of the data to include in the test set.</span>
<span class="sd">        Value must be in the (0, 1) range.</span>
<span class="sd">    shuffle : bool, default=False</span>
<span class="sd">        If shuffle=True, the data samples will be shuffled before splitting.</span>
<span class="sd">    random_state : int, default=0</span>
<span class="sd">        Specifying a nonzero integer to get the same split every time.</span>
<span class="sd">        If random_state=0, each time the data will be split randomly</span>
<span class="sd">        and the results may be different.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    splitting : list</span>
<span class="sd">        List containing four elements: `x_train`, `x_test`, `y_train` and `y_test` arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; X = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]</span>
<span class="sd">    &gt;&gt;&gt; y = [3, 5, 7, 9, 11]</span>
<span class="sd">    &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y)</span>
<span class="sd">    &gt;&gt;&gt; x_train, y_train</span>
<span class="sd">    (array([[1., 2.],</span>
<span class="sd">           [3., 4.],</span>
<span class="sd">           [5., 6.],</span>
<span class="sd">           [7., 8.]]), array([3., 5., 7., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x_test, y_test</span>
<span class="sd">    (array([[ 9., 10.]]), array([11.]))</span>

<span class="sd">    Specifying the `test_size`:</span>

<span class="sd">    &gt;&gt;&gt; x_train, x_test, y_train, y_test = gmdh.split_data(X, y, test_size=0.6)</span>
<span class="sd">    &gt;&gt;&gt; x_train, y_train</span>
<span class="sd">    (array([[1., 2.],</span>
<span class="sd">           [3., 4.]]), array([3., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; x_test, y_test</span>
<span class="sd">    (array([[ 5.,  6.],</span>
<span class="sd">           [ 7.,  8.],</span>
<span class="sd">           [ 9., 10.]]), array([ 7.,  9., 11.]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_gmdh_core</span><span class="o">.</span><span class="n">split_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">x_train</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">x_test</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y_train</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y_test</span><span class="p">]</span></div>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Baryyshnikov Mikhail<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>